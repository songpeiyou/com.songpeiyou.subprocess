/**
 * This class is modified by Peiyou Song (SongPeiyou@gmail.com)
 * 
 * The following is from the original java doc.
 * 
 * ---------------------------------
 * This class can be used to execute a system command from a Java application.
 * See the documentation for the public methods of this class for more
 * information.
 * 
 * Documentation for this class is available at this URL:
 * 
 * http://devdaily.com/java/java-processbuilder-process-system-exec
 * 
 * Copyright 2010 alvin j. alexander, devdaily.com.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 * Please see the following page for the LGPL license:
 * http://www.gnu.org/licenses/lgpl.txt
 * 
 */

package com.songpeiyou.subprocess;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SystemCommandExecutor {
	public static final int NotFinish = -9999;
	private List<String> commandInformation;
	private ThreadedStreamHandler inputStreamHandler;
	private ThreadedStreamHandler errorStreamHandler;
	private ThreadedFinisher finisher;

	private CallBackable callback = null;
	private Map<String, Object> info = new HashMap<String, Object>();
	private boolean printoutput = false;
	private boolean printerr = false;

	private long timeoutSec = 0;

	private Process process;

	public SystemCommandExecutor(final List<String> commandInformation) {
		if (commandInformation == null)
			throw new NullPointerException("The commandInformation is required.");
		this.commandInformation = commandInformation;
	}

	public void executeCommand() throws IOException, InterruptedException {
		executeCommand(false);
	}

	public void kill() throws InterruptedException, IOException {
		process.destroy();
		inputStreamHandler.join();
		errorStreamHandler.join();
	}

	/**
	 * 
	 * @param background True then submit the command and go on immediately. False then wait until the process finished.
	 * @throws IOException
	 * @throws InterruptedException
	 */
	public void executeCommand(boolean background) throws IOException, InterruptedException {
		try {
			ProcessBuilder pb = new ProcessBuilder(commandInformation);

			process = pb.start();

			OutputStream stdOutput = process.getOutputStream();
			InputStream inputStream = process.getInputStream();
			InputStream errorStream = process.getErrorStream();

			inputStreamHandler = new ThreadedStreamHandler(inputStream, stdOutput, isPrintoutput());
			errorStreamHandler = new ThreadedStreamHandler(errorStream);
			inputStreamHandler.setDaemon(true);
			errorStreamHandler.setDaemon(true);

			inputStreamHandler.start();
			errorStreamHandler.start();

			if (this.callback != null || this.timeoutSec > 0) {
				finisher = new ThreadedFinisher(this);
				finisher.setDaemon(true);
				finisher.start();
			}

			// Wait until the process finished.
			if (!background) {
				forgroundrun();
			}

		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		} catch (InterruptedException e) {
			e.printStackTrace();
			// generated by process.waitFor() call
			throw e;
		}
	}

	public void forgroundrun() throws InterruptedException {
		process.waitFor();
		inputStreamHandler.join();
		errorStreamHandler.join();
		if (this.callback != null) {
			finisher.join();
		}
	}

	/**
	 * Get the standard output (stdout) from the command you just exec'd.
	 */
	public StringBuilder getStandardOutputFromCommand() {
		return inputStreamHandler.getOutputBuffer();
	}

	/**
	 * Get the standard error (stderr) from the command you just exec'd.
	 */
	public StringBuilder getStandardErrorFromCommand() {
		return errorStreamHandler.getOutputBuffer();
	}

	public Process getProcess() {
		return process;
	}

	public int exitValue() {
		try {
			return process.exitValue();
		} catch (IllegalThreadStateException e) {
			return NotFinish;
		}
	}

	public static void kill(SystemCommandExecutor exe) throws InterruptedException, IOException {
		exe.kill();
	}

	public static void kill(List<SystemCommandExecutor> exes) throws InterruptedException, IOException {
		for (SystemCommandExecutor exe : exes) {
			exe.kill();
		}
	}

	public static void wait4finish(List<SystemCommandExecutor> exes) throws InterruptedException {
		for (SystemCommandExecutor exe : exes) {
			while (exe.exitValue() == SystemCommandExecutor.NotFinish) {
				Thread.sleep(1000);
			}
		}
	}

	public CallBackable getCallback() {
		return callback;
	}

	public void setCallback(CallBackable callback) {
		this.callback = callback;
	}

	public Map<String, Object> getInfo() {
		return info;
	}

	public void setInfo(Map<String, Object> info) {
		this.info = info;
	}

	public void putInfo(String k, Object v) {
		this.info.put(k, v);
	}

	public Object getInfo(String k) {
		return this.info.get(k);
	}

	public String getString(String k) {
		return (String) getInfo(k);
	}

	public boolean isPrintoutput() {
		return printoutput;
	}

	public void setPrintoutput(boolean printoutput) {
		this.printoutput = printoutput;
	}

	public boolean isPrinterr() {
		return printerr;
	}

	public void setPrinterr(boolean printerr) {
		this.printerr = printerr;
	}

	public long getTimeoutSec() {
		return timeoutSec;
	}

	public void setTimeoutSec(long timeoutSec) {
		this.timeoutSec = timeoutSec;
	}

}
