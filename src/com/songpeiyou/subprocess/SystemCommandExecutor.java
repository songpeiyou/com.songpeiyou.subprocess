/**
 * This class is modified by Peiyou Song (SongPeiyou@gmail.com)
 * 
 * The following is from the original java doc.
 * 
 * --------------------------------- This class can be used to execute a system command from a Java
 * application. See the documentation for the public methods of this class for more information.
 * 
 * Documentation for this class is available at this URL:
 * 
 * http://devdaily.com/java/java-processbuilder-process-system-exec
 * 
 * Copyright 2010 alvin j. alexander, devdaily.com.
 * 
 * This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Lesser Public License as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser Public License along with this program. If not,
 * see <http://www.gnu.org/licenses/>.
 * 
 * Please see the following page for the LGPL license: http://www.gnu.org/licenses/lgpl.txt
 * 
 */

package com.songpeiyou.subprocess;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SystemCommandExecutor {
  public static final int NotFinish = -9999;
  private List<String> commandInformation;
  private ThreadedStreamHandler inputStreamHandler;
  private ThreadedStreamHandler errorStreamHandler;
  private ThreadedFinisher finisher;

  private CallBackable callback = null;
  private Map<String, Object> info = new HashMap<>();
  private boolean printoutput = false;
  private boolean printerr = false;

  private long timeoutSec = 0;

  private Process process;

  public SystemCommandExecutor(final List<String> commandInformation) {
    if (commandInformation == null)
      throw new NullPointerException("The commandInformation is required.");
    this.commandInformation = commandInformation;
  }

  public void executeCommand() throws IOException, InterruptedException {
    executeCommand(false);
  }

  public void kill() throws InterruptedException {
    this.process.destroy();
    this.inputStreamHandler.join();
    this.errorStreamHandler.join();
  }

  /**
   * 
   * @param background True then submit the command and go on immediately. False then wait until the
   *        process finished.
   * @throws IOException
   * @throws InterruptedException
   */
  public void executeCommand(boolean background) throws IOException, InterruptedException {
    try {
      ProcessBuilder pb = new ProcessBuilder(this.commandInformation);

      this.process = pb.start();

      this.inputStreamHandler = new ThreadedStreamHandler(this.process.getInputStream(), this.process.getOutputStream(), isPrintoutput());
      this.errorStreamHandler = new ThreadedStreamHandler(this.process.getErrorStream());
      this.inputStreamHandler.setDaemon(true);
      this.errorStreamHandler.setDaemon(true);

      this.inputStreamHandler.start();
      this.errorStreamHandler.start();

      if (this.callback != null || this.timeoutSec > 0) {
        this.finisher = new ThreadedFinisher(this);
        this.finisher.setDaemon(true);
        this.finisher.start();
      }

      // Wait until the process finished.
      if (!background) {
        forgroundrun();
      }

    } catch (IOException e) {
      e.printStackTrace();
      throw e;
    } catch (InterruptedException e) {
      e.printStackTrace();
      // generated by process.waitFor() call
      throw e;
    }
  }

  public void forgroundrun() throws InterruptedException {
    this.process.waitFor();
    this.inputStreamHandler.join();
    this.errorStreamHandler.join();
    if (this.callback != null) {
      this.finisher.join();
    }
  }

  /**
   * Get the standard output (stdout) from the command you just exec'd.
   */
  public StringBuffer getStandardOutputFromCommand() {
    return this.inputStreamHandler.getOutputBuffer();
  }

  /**
   * Get the standard error (stderr) from the command you just exec'd.
   */
  public StringBuffer getStandardErrorFromCommand() {
    return this.errorStreamHandler.getOutputBuffer();
  }

  public Process getProcess() {
    return this.process;
  }

  public int exitValue() {
    try {
      return this.process.exitValue();
    } catch (IllegalThreadStateException e) {
      return NotFinish;
    }
  }

  public static void kill(SystemCommandExecutor exe) throws InterruptedException {
    exe.kill();
  }

  public static void kill(List<SystemCommandExecutor> exes) throws InterruptedException {
    for (SystemCommandExecutor exe : exes) {
      exe.kill();
    }
  }

  public static void wait4finish(List<SystemCommandExecutor> exes) throws InterruptedException {
    for (SystemCommandExecutor exe : exes) {
      while (exe.exitValue() == SystemCommandExecutor.NotFinish) {
        Thread.sleep(1000);
      }
    }
  }

  public CallBackable getCallback() {
    return this.callback;
  }

  public void setCallback(CallBackable callback) {
    this.callback = callback;
  }

  public Map<String, Object> getInfo() {
    return this.info;
  }

  public void setInfo(Map<String, Object> info) {
    this.info = info;
  }

  public void putInfo(String k, Object v) {
    this.info.put(k, v);
  }

  public Object getInfo(String k) {
    return this.info.get(k);
  }

  public String getString(String k) {
    return (String) getInfo(k);
  }

  public boolean isPrintoutput() {
    return this.printoutput;
  }

  public void setPrintoutput(boolean printoutput) {
    this.printoutput = printoutput;
  }

  public boolean isPrinterr() {
    return this.printerr;
  }

  public void setPrinterr(boolean printerr) {
    this.printerr = printerr;
  }

  public long getTimeoutSec() {
    return this.timeoutSec;
  }

  public void setTimeoutSec(long timeoutSec) {
    this.timeoutSec = timeoutSec;
  }

}
